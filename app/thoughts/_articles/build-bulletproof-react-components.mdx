export const metadata = {
  title: "Building Bulletproof React Components",
  date: "2026.02.03",
  description: "Components that survive the wild—across SSR, hydration, portals, RSC, and view transitions.",
}

# Building Bulletproof React Components

> I skate to where the puck is going to be, not where it has been.  
> — Wayne Gretzky

Most components are built for the happy path. They work—until they don’t. The real world is hostile. Server rendering. Hydration. Multiple instances. Concurrent rendering. Async children. Portals... Your component could face all of them. The question is whether it survives.

The real test isn’t whether your component works on your current page. It’s whether it works when someone else uses it—in conditions you didn’t plan for. That’s when _fragile_ components break.

Here’s how to make it _survive_.

1. [Make It __Server__-Proof](#make-it-server-proof)
2. [Make It __Hydration__-Proof](#make-it-hydration-proof)
3. [Make It __Instance__-Proof](#make-it-instance-proof)
4. [Make It __Concurrent__-Proof](#make-it-concurrent-proof)
5. [Make It __Composition__-Proof](#make-it-composition-proof)
6. [Make It __Portal__-Proof](#make-it-portal-proof)
7. [Make It __Transition__-Proof](#make-it-transition-proof)
8. [Make It __Activity__-Proof](#make-it-activity-proof)
9. [Make It __Future__-Proof<sup>*</sup>](#make-it-future-proof)

## Make It Server-Proof

A simple theme provider that reads the user’s preference from `localStorage`:

<BlockSideTitle title="Crashes in SSR—reads theme from localStorage">

```jsx
// [!code word:localStorage]
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(
    localStorage.getItem('theme') || 'light'
  )

  return <div className={theme}>{children}</div>
}
```

</BlockSideTitle>

But `localStorage` doesn’t exist on the server. In Next.js, Remix, or any SSR framework, this crashes the build. Move browser APIs into `useEffect`:

<BlockSideTitle title="useEffect defers localStorage to client-side only">

```jsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  // [!code highlight:3]
  useEffect(() => {
    setTheme(localStorage.getItem('theme') || 'light')
  }, [])

  return <div className={theme}>{children}</div>
}
```

</BlockSideTitle>

Now it renders on the server without crashing.

## Make It Hydration-Proof

The server-safe version works, but users see a flash. Server renders `light`, client hydrates, then the effect runs and switches to `dark`:

<BlockSideTitle title="Flash of wrong theme—useEffect runs after hydration">

```jsx
function ThemeProvider({ children }) {
  // [!code word:'light':1]
  const [theme, setTheme] = useState('light')

  useEffect(() => {
    setTheme(localStorage.getItem('theme') || 'light')
  }, [])

  return <div className={theme}>{children}</div>
}
```

</BlockSideTitle>

Inject a synchronous script that sets the correct value *before* browser paints and React hydrates. The DOM already has the right class when React takes over:

<BlockSideTitle title="Inline script sets theme before browser paints">

```jsx
function ThemeProvider({ children }) {
  return (
    <>
      <div id="theme">{children}</div>
      // [!code highlight:6]
      <script dangerouslySetInnerHTML={{ __html: `
        try {
          const theme = localStorage.getItem('theme') || 'light'
          document.getElementById('theme').className = theme
        } catch (e) {}
      `}} />
    </>
  )
}
```

</BlockSideTitle>

No mismatch, no flash.

## Make It Instance-Proof

The hydration-proof version targets a hardcoded `id="theme"`. But what if someone uses two `ThemeProvider`s?

<BlockSideTitle title="Multiple instances—both scripts target the same ID">

```jsx
// [!code word:<ThemeProvider>]
// [!code word:</ThemeProvider>]
function App() {
  return (
    <>
      <ThemeProvider><MainContent /></ThemeProvider>
      <AlwaysLightThemeContent />
      <ThemeProvider><Sidebar /></ThemeProvider>
    </>
  )
}
```

</BlockSideTitle>

Both scripts fight over the same element. Use [`useId`](https://react.dev/reference/react/useId) to generate stable, unique IDs per instance:

<BlockSideTitle title="useId generates unique IDs per instance">

```jsx
function ThemeProvider({ children }) {
  // [!code highlight:1]
  const id = useId()
  return (
    <>
      // [!code highlight:1]
      <div id={id}>{children}</div>
      <script dangerouslySetInnerHTML={{ __html: `
        try {
          const theme = localStorage.getItem('theme') || 'light'
          // [!code highlight:1]
          document.getElementById('${id}').className = theme
        } catch (e) {}
      `}} />
    </>
  )
}
```

</BlockSideTitle>

Now multiple instances coexist safely.

## Make It Concurrent-Proof

Now let’s make the theme server-driven. A [Server Component](https://react.dev/reference/rsc/server-components) that fetches user preferences:

<BlockSideTitle title="Server Component fetches preferences from database">

```jsx
async function ThemeProvider({ children }) {
  // [!code word:await db.preferences.get(userId)]
  const prefs = await db.preferences.get(userId)

  return <div className={prefs.theme}>{children}</div>
}
```

</BlockSideTitle>

Similar to before, render it in two places and you might get two identical database queries. Wrap the query in [`cache()`](https://react.dev/reference/react/cache) to deduplicate within a single request:

<BlockSideTitle title="React cache() deduplicates concurrent calls">

```jsx
import { cache } from 'react'

// [!code highlight:3]
const getPreferences = cache(
  userId => db.preferences.get(userId)
)

async function ThemeProvider({ children }) {
  const prefs = await getPreferences(userId)

  return <div className={prefs.theme}>{children}</div>
}
```

</BlockSideTitle>

Same query, called from anywhere, hits the database once.

## Make It Composition-Proof

Sometimes you want to pass data to children as props, which traditionally meant using `React.cloneElement`:

<BlockSideTitle title="Passes theme to children via cloneElement">

```jsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  // [!code word:React.Children.map]
  return React.Children.map(children, (child) => {
    // [!code word:React.cloneElement]
    return React.cloneElement(child, { theme })
  })
}
```

</BlockSideTitle>

But with [React Server Components](https://react.dev/reference/rsc/server-components), [`React.lazy`](https://react.dev/reference/react/lazy), or [`"use cache"`](https://nextjs.org/docs/app/api-reference/directives/use-cache), `children` might be a Promise or an [opaque reference](https://react.dev/reference/react/Children#why-is-the-children-prop-not-always-an-array)—`cloneElement` won't work. Use context instead:

<BlockSideTitle title="Context works everywhere—server, client, async">

```jsx
const ThemeContext = createContext('light')

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  return (
    // [!code highlight:3]
    <ThemeContext.Provider value={theme}>
      {children}
    </ThemeContext.Provider>
  )
}
```

</BlockSideTitle>

Children read the theme through `useContext`—no prop drilling, no cloning.

## Make It Portal-Proof

A theme provider with a keyboard shortcut—`Cmd+D` to toggle dark mode:

<BlockSideTitle title="Global keyboard shortcut to toggle theme">

```jsx
// [!code word:window]
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')

  useEffect(() => {
    const toggle = (e) => {
      if (e.metaKey && e.key === 'd') {
        e.preventDefault()
        setTheme(t => t === 'dark' ? 'light' : 'dark')
      }
    }
    window.addEventListener('keydown', toggle)
    return () => window.removeEventListener('keydown', toggle)
  }, [])

  return <div className={theme}>{children}</div>
}
```

</BlockSideTitle>

But if someone renders the app inside a pop-out window, iframe, or via [`createPortal`](https://react.dev/reference/react-dom/createPortal), the shortcut stops working. The listener is attached to the parent `window`, not the one your component lives in. Use `ownerDocument.defaultView`:

<BlockSideTitle title="ownerDocument.defaultView finds the correct window">

```jsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')
  const ref = useRef(null)

  useEffect(() => {
    // [!code highlight:1]
    const win = ref.current?.ownerDocument.defaultView || window
    const toggle = (e) => {
      if (e.metaKey && e.key === 'd') {
        e.preventDefault()
        setTheme(t => t === 'dark' ? 'light' : 'dark')
      }
    }
    win.addEventListener('keydown', toggle)
    return () => win.removeEventListener('keydown', toggle)
  }, [])

  return <div ref={ref} className={theme}>{children}</div>
}
```

</BlockSideTitle>

Now the shortcut works in any window context.

## Make It Transition-Proof

A settings panel that toggles between simple and advanced views:

<BlockSideTitle title="Simple state toggle between two panels">

```jsx
function ThemeSettings() {
  const [showAdvanced, setShowAdvanced] = useState(false)

  return (
    <>
      {showAdvanced ? <AdvancedPanel /> : <SimplePanel />}
      // [!code word:setShowAdvanced]
      <button onClick={() => setShowAdvanced(!showAdvanced)}>
        {showAdvanced ? 'Simple' : 'Advanced'}
      </button>
    </>
  )
}
```

</BlockSideTitle>

Wrap it in React 19’s [`<ViewTransition>`](https://react.dev/reference/react/ViewTransition), and nothing animates—the panels just snap. State updates must go through `startTransition`:

<BlockSideTitle title="startTransition enables the view transition">

```jsx
function ThemeSettings() {
  const [showAdvanced, setShowAdvanced] = useState(false)

  return (
    <>
      {showAdvanced ? <AdvancedPanel /> : <SimplePanel />}
      <button onClick={() =>
        // [!code highlight:1]
        startTransition(() => setShowAdvanced(!showAdvanced))
      }>
        {showAdvanced ? 'Simple' : 'Advanced'}
      </button>
    </>
  )
}
```

</BlockSideTitle>

Now the transition animates smoothly.

## Make It Activity-Proof

A theme component that injects CSS variables via a `<style>` tag:

<BlockSideTitle title="Injects global CSS variables via style tag">

```jsx
// [!code word:<style>]
// [!code word:</style>]
function DarkTheme({ children }) {
  return (
    <>
      <style>{`
        :root {
          --bg: #000;
          --fg: #fff;
        }
      `}</style>
      {children}
    </>
  )
}
```

</BlockSideTitle>

But if you wrap it in [`<Activity>`](https://react.dev/reference/react/Activity), the dark theme persists even when hidden. `<Activity>` preserves DOM, and `<style>` has DOM-level side effects—it modifies `:root` variables globally. React can't automatically clean up these side effects. Set `media="not all"` to disable the styles when hidden:

<BlockSideTitle title="useLayoutEffect sets media='not all' when hidden and restores it when unhidden">

```jsx
function DarkTheme({ children }) {
  const ref = useRef(null)

  // [!code highlight:5]
  useLayoutEffect(() => {
    if (!ref.current) return
    ref.current.media = 'all'
    return () => ref.current.media = 'not all'
  }, [])

  return (
    <>
      <style ref={ref}>{`
        :root {
          --bg: #000;
          --fg: #fff;
        }
      `}</style>
      {children}
    </>
  )
}
```

</BlockSideTitle>

Now hidden components won't have the dark theme applied.

## Make It Future-Proof<sup>*</sup>

_This is a concept to understand: be defensive. It is not a pattern to apply everywhere._

A theme that generates random accent colors on mount:

<BlockSideTitle title="useMemo caches the generated colors">

```jsx
function ThemeProvider({ baseTheme, children }) {
  // [!code word:useMemo]
  const colors = useMemo(
    () => getRandomColors(baseTheme),
    [baseTheme]
  )

  return <div style={colors}>{children}</div>
}
```

</BlockSideTitle>

But `useMemo` is a [performance hint, not a semantic guarantee](https://react.dev/reference/react/useMemo#caveats). React discards cached values during HMR, and reserves the right to do so for offscreen components or features that don’t exist yet. If React discards the cache, your theme flickers to different colors. Use state when correctness depends on persistence:

<BlockSideTitle title="useState provides semantic persistence guarantee">

```jsx
function ThemeProvider({ baseTheme, children }) {
  // [!code highlight:2]
  const [colors, setColors] = useState(() => generateAccentColors(baseTheme))
  const [prevTheme, setPrevTheme] = useState(baseTheme)

  // [!code highlight:4]
  if (baseTheme !== prevTheme) {
    setPrevTheme(baseTheme)
    setColors(generateAccentColors(baseTheme))
  }

  return <div style={colors}>{children}</div>
}
```

</BlockSideTitle>

Now colors stay stable regardless of React’s internal optimizations.

---

These aren’t edge cases. They’re the new normal. The components that break? They weren’t fragile. They were built for yesterday’s React. We’re building for tomorrow’s.

---

Thanks to [Jiachi](https://huozhi.im) for __proof__-reading.

